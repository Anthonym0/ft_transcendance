input {
  file {
    path => "/usr/share/logstash/input_logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    exclude => "*.swp"
    codec => plain { charset => "UTF-8" }
  }
}

filter {
  ruby {
    code => '
      filename = event.get("path")&.split("/")&.last
      if filename
        service_name = filename.gsub(".log", "")
        event.set("service_name", service_name)
        event.set("[parsed_log][service_name]", service_name)
      end
    '
  }

  json {
    source => "message"
    target => "parsed_log"
    skip_on_invalid_json => true
  }

  if ![parsed_log][message] {
    grok {
      match => {
        "message" => [
          "(%{TIMESTAMP_ISO8601:parsed_log.timestamp}|%{TIMESTAMP_ISO8601:timestamp})\s*\[?%{LOGLEVEL:parsed_log.levelname}\]?\s*(%{GREEDYDATA:parsed_log.message})",
          "%{GREEDYDATA:parsed_log.message}"
        ]
      }
      tag_on_failure => []
    }
  }

  if [parsed_log][timestamp] {
    date {
      match => ["parsed_log.timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }

  if [parsed_log][level] and ![parsed_log][levelname] {
    mutate {
      rename => { "[parsed_log][level]" => "[parsed_log][levelname]" }
    }
  }

  if ![parsed_log][levelname] {
    mutate {
      add_field => { "[parsed_log][levelname]" => "UNSPECIFIED" }
    }
  }

  ruby {
    code => '
      if event.get("parsed_log").is_a?(Hash)
        event.set("[parsed_log][origin]", event.get("path")) unless event.get("[parsed_log][origin]")
      end
    '
  } 

  if [service_name] == "postgres" {
    grok {
      match => {
        "parsed_log.message" => "%{TIMESTAMP_ISO8601:parsed_log.timestamp} UTC \[%{INT:pg_pid}\] %{WORD:pg_level}: %{GREEDYDATA:parsed_log.message}"
      }
      tag_on_failure => []
    }

    mutate {
      rename => { "pg_level" => "[parsed_log][levelname]" }
    }
  }

  if [parsed_log][levelname] == "LOG" {
    mutate {
      replace => { "[parsed_log][levelname]" => "INFO" }
    }
  }

  if [parsed_log][levelname] == "UNSPECIFIED" {
    mutate {
      replace => { "[parsed_log][levelname]" => "INFO" }
    }
  }

  if [parsed_log][levelname] == "WARNING" {
    mutate {
      replace => { "[parsed_log][levelname]" => "WARN" }
    }
  }

   mutate {
    remove_field => ["message", "path", "host", "stream", "@version"]
  }

}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "${ELASTIC_USERNAME}"
    password => "${ELASTIC_PASSWORD}"
    index => "transcendance-filtered"
  }

  # stdout {
  #   codec => rubydebug
  # }
}
